<!--
title: 感性理解 Rust 多重引用与命
created: 2019-02-02T01:23:00+0800
tags:
- rust
- lifetime
- type
-->

**注意：本文分析为本人随机推断的，没读过 rustc 源码，仅供感性理解，如有错误请 [issue](/?article=about)。**

考虑 Rust 分可不可变引用，以两层为例，那么我们就有四种情况：
- `&'a &'b T`
- `&'a &'b mut T`
- `&'a mut &'b T`
- `&'a mut &'b mut T`

对上述类型各自解引用（`*`）会得到一个一级引用，显然只有最后一个结果是可变引用，但它们各自的命是多长？

> 我把“ lifetime ”翻译为“命”，它另一个更广泛的译名是“生命周期”。
> 我觉得这个“周期”概念完全是无中生有，所以不太喜欢用。
> 你们知道是一个东西就好，我在其他地方也可能这么说，恕不复述。

# 0. Pre. Puzzle.

为什么想到这个问题呢，因为正好群里有人遇到了个命不匹配的错误。
它对一个 `&'a mut &'b mut T` 的类型解引用试图传给需要 `&'b mut T` 的函数，但编译失败了。

“解引用不应该是解掉外层引用吗？为什么不能得到里层类型呢？”

# 1. 解引用

我们需要考虑的问题就是解引用到底怎么解。

考虑一个引用，我们把所有涉及的命标出来记作 `&'a [mut] T + 'b` ，其中 `T: 'c`。
- `'a` 是引用的有效期。
- `'b` 是这个引用自己的命，通常是引用类型的变量所在的 scope。
- `'c` 是被引用类型的命长（比如被引用对象还是个引用），出了范围类型就死了，更别说对象了。对于普通“纯值”类型来说，有 `i32, bool, String, ...: 'static`。

显然我们必须有：
- `'c: 'a` ，即 `T: 'a`
- `'a: 'b`

## i. 不可变引用

`* &'a T + 'b => T + '_`

这个 `'_` 多大合适呢？就是问这个 `T` 类型的**对象**最多到哪里还是活着（可用）的。
我们从小到大考虑：

- 在 `'b` ，大家都活着，当然没问题。
- 出了 `'b` 的 `'a` ，引用死了，但引用有效期还没过，可以知道还被借着，那么我们可以随意借随便丟（同一时刻可有任意多个可变引用，且是 Copy 的），可以继续安心使用它。
- 出了 `'a` 的 `'c` ，被引用类型活着，但引用过期了，人家拿回去自己玩（移动，变化）了，你不能再碰了。

所以这里的命长是 `'a`

## ii. 可变引用

`* &'a mut T + 'b => mut T + '_`

- 在 `'b` ，都活着，可用。
- 出了 `'b` 的 `'a` ，可变引用死了，完蛋，因为同一时间只能有一个可变引用，死了自动归还上层（如果是从上层 reborrow 来），有效引用现在只有上层有了，你 gg 。

所以这里的命长是 `'b` ，短一些。

## 所以...

- `* &'a T + 'b => T + 'a`
- `* &'a mut T + 'b => mut T + 'b`

这里的命长差异实际是由可变引用的互斥性导致的。
如果你没有梦想，放弃可变性，那可以得到不可变引用一样的长命（大雾），比如：

- `* &'a mut T + 'b => T + 'a`

# 2. `* &'a [mut] &'b T`

那么问题来了，我们怎么构造一个 `&'a T + 'b` 呢？

`'a` 直接照写就好，`'b` 是指一个引用的命，我们直接把引用藏在引用后面，那么外层引用的有效期就是内层引用的命了。这正是我们要讨论的。

`* &'a [mut] &'b T => &'b T + 'a` （放弃梦想）

我们得到了内层引用，它自己 `'a` 比较短命，但借用的有效期 `'b` 比较长

由于不可变引用是 `Copy` 的，可以直接复制出来得到长命引用 `&'b T`，然后 `return`。

```rust
fn deref_imm_imm<'a, 'b: 'a, T: 'b>(p: &'a &'b T) -> &'b T {
    // p // 自动 deref，自动 reborrow，这么写也可以（真随意.jpg)
    *p
}

fn deref_mut_imm<'a, 'b: 'a, T: 'b>(p: &'a mut &'b T) -> &'b T {
    // p
    *p
}
```

# 3. `* &'a mut &'b mut T`

同样地：

`* &'a mut &'b mut T => &'b mut T + 'a` （放弃梦想，因为我们不想改引用指向）

然后麻烦了，我们的可变借用不是 `Copy` 的，我们想返回一个 `&mut T` 的话又必须把这个引用搞出来...

这时就需要一个机制，reborrow 。
我们不是要一个一级引用吗？那再 `*` 得到对象本身，再 `&mut` 重新借一个出来呗。

```rust
&mut * (&'b mut T + 'a) =>
&mut (mut T + 'a) => // 需要 mut ，只能拿到短命
&'a mut T
```

诶，这下变成短命 `'a` 了，都怪我们没有放弃梦想（逃

下面代码返回的命改成 `'b` 将会编译错误。

```rust
fn deref_imm_mut<'a, 'b: 'a, T: 'b>(p: &'a &'b mut T) -> &'a T {
    // p
    &**p
}

fn deref_mut_mut<'a, 'b: 'a, T: 'b>(p: &'a mut &'b mut T) -> &'a mut T {
    // p
    &mut **p
}
```

# 4. What if ... reborrow in #2 ?

```rust
&** &'a [mut] &'b T =>
&* ([mut] &'b T + 'a) =>
& (T + 'b) => // 放弃了梦想，变成咸鱼
&'b T
```

当然是一样的啦。

# 5. 总结一下

- `* &'a [mut] &'b T => &'b T` (Copy or reborrow)
- `[&mut *] * &'a mut &'b mut T => &'a mut T` (Reborrow only)
- `[&mut *] * &'a &'b mut T => &'a T` (Reborrow only)

